using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace SimpleBranchVersioning;

/// <summary>
/// Source generator that creates an AppVersion class with version information from git.
/// </summary>
[Generator]
public sealed class AppVersionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get project directory and namespace from MSBuild properties
        var buildPropertiesProvider = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) =>
            {
                provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace);
                provider.GlobalOptions.TryGetValue("build_property.ProjectDir", out var projectDir);

                // Read git info from files
                var (branch, commitId) = ReadGitInfo(projectDir);

                return new BuildProperties(rootNamespace, branch, commitId);
            });

        // Look for AppVersionConfigAttribute in assembly attributes
        var configAttributeProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "SimpleBranchVersioning.AppVersionConfigAttribute",
                predicate: static (node, _) => node is CompilationUnitSyntax,
                transform: static (ctx, _) => GetConfigFromAttribute(ctx))
            .Collect()
            .Select((configs, _) => configs.IsDefaultOrEmpty ? null : configs[0]);

        // Combine all the inputs
        var combined = buildPropertiesProvider.Combine(configAttributeProvider);

        // Register the source output
        context.RegisterSourceOutput(combined, static (ctx, input) =>
        {
            var (buildProps, config) = input;

            var branch = string.IsNullOrEmpty(buildProps.Branch) ? "unknown" : buildProps.Branch!;
            var commitId = string.IsNullOrEmpty(buildProps.CommitId) ? "0000000" : buildProps.CommitId!;
            var version = VersionCalculator.Calculate(branch, commitId);
            var namespaceName = config?.Namespace ?? buildProps.RootNamespace ?? "SimpleBranchVersioning.Generated";
            var className = config?.ClassName ?? "AppVersion";

            var source = GenerateSource(namespaceName, className, version, branch, commitId);
            ctx.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static AppVersionConfig? GetConfigFromAttribute(GeneratorAttributeSyntaxContext context)
    {
        var attribute = context.Attributes.FirstOrDefault();
        if (attribute is null)
            return null;

        string? namespaceName = null;
        string? className = null;

        foreach (var arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "Namespace":
                    namespaceName = arg.Value.Value as string;
                    break;
                case "ClassName":
                    className = arg.Value.Value as string;
                    break;
            }
        }

        return new AppVersionConfig(namespaceName, className);
    }

    private static string GenerateSource(string namespaceName, string className, string version, string branch, string commitId)
    {
        return $@"// <auto-generated/>
#nullable enable

namespace {namespaceName}
{{
    /// <summary>
    /// Contains version information generated from git.
    /// </summary>
    public static class {className}
    {{
        /// <summary>
        /// The full version string.
        /// </summary>
        public const string Version = ""{version}"";

        /// <summary>
        /// The git branch name.
        /// </summary>
        public const string Branch = ""{branch}"";

        /// <summary>
        /// The short git commit ID.
        /// </summary>
        public const string CommitId = ""{commitId}"";
    }}
}}";
    }

    private static (string? branch, string? commitId) ReadGitInfo(string? projectDir)
    {
        if (string.IsNullOrEmpty(projectDir))
            return (null, null);

        // Find .git directory by walking up the directory tree
        var dir = new DirectoryInfo(projectDir);
        string? gitDir = null;

        while (dir != null)
        {
            var gitPath = Path.Combine(dir.FullName, ".git");
            if (Directory.Exists(gitPath))
            {
                gitDir = gitPath;
                break;
            }
            dir = dir.Parent;
        }

        if (gitDir == null)
            return (null, null);

        // Read HEAD file
        var headPath = Path.Combine(gitDir, "HEAD");
        if (!File.Exists(headPath))
            return (null, null);

        var headContent = File.ReadAllText(headPath).Trim();

        string? branch = null;
        string? commitId = null;

        // Parse HEAD - either "ref: refs/heads/branch-name" or a commit hash
        if (headContent.StartsWith("ref: refs/heads/"))
        {
            branch = headContent.Substring(16);

            // Read commit from ref file
            var refPath = Path.Combine(gitDir, "refs", "heads", branch);
            if (File.Exists(refPath))
            {
                var commit = File.ReadAllText(refPath).Trim();
                if (commit.Length >= 7)
                    commitId = commit.Substring(0, 7);
            }
        }
        else if (headContent.Length >= 7 && Regex.IsMatch(headContent, "^[0-9a-f]+$"))
        {
            // Detached HEAD - commit hash directly in HEAD
            branch = "detached";
            commitId = headContent.Substring(0, 7);
        }

        return (branch, commitId);
    }

    private sealed record BuildProperties(string? RootNamespace, string? Branch, string? CommitId);
    private sealed record AppVersionConfig(string? Namespace, string? ClassName);
}
