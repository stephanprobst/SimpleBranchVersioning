using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SimpleBranchVersioning;

/// <summary>
/// Source generator that creates an AppVersion class with version information from git.
/// </summary>
[Generator]
public sealed class AppVersionGenerator : IIncrementalGenerator
{
    private const string AttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace SimpleBranchVersioning
        {
            /// <summary>
            /// Configures the generated AppVersion class.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Assembly)]
            internal sealed class AppVersionConfigAttribute : global::System.Attribute
            {
                /// <summary>
                /// The namespace for the generated AppVersion class.
                /// If not specified:
                /// - For top-level statement apps: global namespace (no using required)
                /// - For other apps: the root namespace of the consuming project
                /// Set to an empty string ("") to explicitly use the global namespace.
                /// </summary>
                public string? Namespace { get; set; }

                /// <summary>
                /// The name of the generated class. Defaults to "AppVersion".
                /// </summary>
                public string? ClassName { get; set; }
            }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Emit the attribute so consumers can use it
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("AppVersionConfigAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8)));

        // Get project directory and namespace from MSBuild properties
        var buildPropertiesProvider = context.AnalyzerConfigOptionsProvider
            .Select((provider, _) =>
            {
                provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out string? rootNamespace);
                provider.GlobalOptions.TryGetValue("build_property.ProjectDir", out string? projectDir);

                // Read git info from files
                var (branch, commitId) = ReadGitInfo(projectDir);

                return new BuildProperties(rootNamespace, branch, commitId);
            });

        // Look for AppVersionConfigAttribute in assembly attributes
        var configAttributeProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "SimpleBranchVersioning.AppVersionConfigAttribute",
                predicate: static (node, _) => node is CompilationUnitSyntax,
                transform: static (ctx, _) => GetConfigFromAttribute(ctx))
            .Collect()
            .Select((configs, _) => configs.IsDefaultOrEmpty ? null : configs[0]);

        // Detect if the project uses top-level statements
        var hasTopLevelStatementsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is GlobalStatementSyntax,
                transform: static (_, _) => true)
            .Collect()
            .Select((results, _) => !results.IsDefaultOrEmpty);

        // Combine all the inputs
        var combined = buildPropertiesProvider
            .Combine(configAttributeProvider)
            .Combine(hasTopLevelStatementsProvider);

        // Register the source output
        context.RegisterSourceOutput(combined, static (ctx, input) =>
        {
            var ((buildProps, config), hasTopLevelStatements) = input;

            string branch = string.IsNullOrEmpty(buildProps.Branch) ? "unknown" : buildProps.Branch!;
            string commitId = string.IsNullOrEmpty(buildProps.CommitId) ? "0000000" : buildProps.CommitId!;
            string version = VersionCalculator.Calculate(branch, commitId);

            // Determine namespace:
            // 1. If config specifies namespace explicitly, use it (empty string = global namespace)
            // 2. If top-level statements detected and no config, use global namespace
            // 3. Otherwise use RootNamespace or fallback
            string? namespaceName;
            if (config?.Namespace != null)
            {
                namespaceName = config.Namespace.Length == 0 ? null : config.Namespace;
            }
            else if (hasTopLevelStatements)
            {
                namespaceName = null; // Global namespace for top-level statement apps
            }
            else
            {
                namespaceName = buildProps.RootNamespace ?? "SimpleBranchVersioning.Generated";
            }
            string className = config?.ClassName ?? "AppVersion";

            string source = GenerateSource(namespaceName, className, version, branch, commitId);
            ctx.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static AppVersionConfig? GetConfigFromAttribute(GeneratorAttributeSyntaxContext context)
    {
        var attribute = context.Attributes.FirstOrDefault();
        if (attribute is null)
        {
            return null;
        }

        string? namespaceName = null;
        string? className = null;

        foreach (var arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "Namespace":
                    namespaceName = arg.Value.Value as string;
                    break;
                case "ClassName":
                    className = arg.Value.Value as string;
                    break;
            }
        }

        return new AppVersionConfig(namespaceName, className);
    }

    private static string GenerateSource(string? namespaceName, string className, string version, string branch, string commitId)
    {
        string classDefinition = $$"""
            /// <summary>
            /// Contains version information generated from git.
            /// </summary>
            public static class {{className}}
            {
                /// <summary>
                /// The full version string.
                /// </summary>
                public const string Version = "{{version}}";

                /// <summary>
                /// The git branch name.
                /// </summary>
                public const string Branch = "{{branch}}";

                /// <summary>
                /// The short git commit ID.
                /// </summary>
                public const string CommitId = "{{commitId}}";
            }
            """;

        if (namespaceName == null)
        {
            return $"""
                // <auto-generated/>
                #nullable enable

                {classDefinition}
                """;
        }

        // Indent the class definition for namespace
        string indentedClass = string.Join(
            "\n",
            classDefinition.Split('\n')
                .Select(line => string.IsNullOrWhiteSpace(line) ? line.TrimEnd('\r') : "    " + line.TrimEnd('\r')));

        return $$"""
            // <auto-generated/>
            #nullable enable

            namespace {{namespaceName}}
            {
            {{indentedClass}}
            }
            """;
    }

#pragma warning disable RS1035 // File IO is intentional - we need to read git info
    private static (string? branch, string? commitId) ReadGitInfo(string? projectDir)
    {
        if (string.IsNullOrEmpty(projectDir))
        {
            return (null, null);
        }

        // Find .git directory by walking up the directory tree
        var dir = new DirectoryInfo(projectDir);
        string? gitDir = null;

        while (dir != null)
        {
            string gitPath = Path.Combine(dir.FullName, ".git");
            if (Directory.Exists(gitPath))
            {
                gitDir = gitPath;
                break;
            }

            dir = dir.Parent;
        }

        if (gitDir == null)
        {
            return (null, null);
        }

        // Read HEAD file
        string headPath = Path.Combine(gitDir, "HEAD");
        if (!File.Exists(headPath))
        {
            return (null, null);
        }

        string headContent = File.ReadAllText(headPath).Trim();

        string? branch = null;
        string? commitId = null;

        // Parse HEAD - either "ref: refs/heads/branch-name" or a commit hash
        if (headContent.StartsWith("ref: refs/heads/", StringComparison.Ordinal))
        {
            branch = headContent.Substring(16);

            // Read commit from ref file
            string refPath = Path.Combine(gitDir, "refs", "heads", branch);
            if (File.Exists(refPath))
            {
                string commit = File.ReadAllText(refPath).Trim();
                if (commit.Length >= 7)
                {
                    commitId = commit.Substring(0, 7);
                }
            }
        }
        else if (headContent.Length >= 7 && Regex.IsMatch(headContent, "^[0-9a-f]+$", RegexOptions.None, TimeSpan.FromSeconds(1)))
        {
            // Detached HEAD - commit hash directly in HEAD
            branch = "detached";
            commitId = headContent.Substring(0, 7);
        }

        return (branch, commitId);
    }
#pragma warning restore RS1035

    private sealed record BuildProperties(string? RootNamespace, string? Branch, string? CommitId);
    private sealed record AppVersionConfig(string? Namespace, string? ClassName);
}
