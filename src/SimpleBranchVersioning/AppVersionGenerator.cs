using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SimpleBranchVersioning;

/// <summary>
/// Source generator that creates an AppVersion class with version information from git.
/// </summary>
[Generator]
public sealed class AppVersionGenerator : IIncrementalGenerator
{
    private const string AttributeSource = """
        // <auto-generated/>
        #nullable enable

        namespace SimpleBranchVersioning
        {
            /// <summary>
            /// Configures the generated AppVersion class.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Assembly)]
            internal sealed class AppVersionConfigAttribute : global::System.Attribute
            {
                /// <summary>
                /// The namespace for the generated AppVersion class.
                /// If not specified:
                /// - For top-level statement apps: global namespace (no using required)
                /// - For other apps: the root namespace of the consuming project
                /// Set to an empty string ("") to explicitly use the global namespace.
                /// </summary>
                public string? Namespace { get; set; }

                /// <summary>
                /// The name of the generated class. Defaults to "AppVersion".
                /// </summary>
                public string? ClassName { get; set; }
            }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Emit the attribute so consumers can use it
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("AppVersionConfigAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8)));

        // Track git HEAD file from AdditionalFiles to trigger rebuild on branch change
        var gitHeadProvider = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith("HEAD", StringComparison.OrdinalIgnoreCase)
                               && file.Path.Contains(".git"))
            .Collect()
            .Select((files, ct) =>
            {
                // Read the HEAD file content and extract git directory path
                var headFile = files.FirstOrDefault();
                if (headFile == null)
                {
                    return (HeadContent: (string?)null, GitDir: (string?)null);
                }

                string? headContent = headFile.GetText(ct)?.ToString()?.Trim();
                // Extract .git directory from the HEAD file path
                string gitDir = Path.GetDirectoryName(headFile.Path) ?? "";
                return (HeadContent: headContent, GitDir: gitDir);
            });

        // Get project directory and namespace from MSBuild properties
        var buildPropertiesProvider = context.AnalyzerConfigOptionsProvider
            .Combine(gitHeadProvider)
            .Select((input, _) =>
            {
                var (provider, gitInfo) = input;
                provider.GlobalOptions.TryGetValue("build_property.RootNamespace", out string? rootNamespace);
                provider.GlobalOptions.TryGetValue("build_property.ProjectDir", out string? projectDir);
                provider.GlobalOptions.TryGetValue("build_property.IncludeCommitIdMetadata", out string? includeMetadataStr);

                // Parse IncludeCommitIdMetadata (default: true)
                bool includeCommitIdMetadata = !string.Equals(includeMetadataStr, "false", StringComparison.OrdinalIgnoreCase);

                // Read git info - prefer using tracked HEAD content, fallback to filesystem
                var (branch, commitId) = ParseGitInfo(gitInfo.HeadContent, gitInfo.GitDir)
                                       ?? ReadGitInfo(projectDir);

                return new BuildProperties(rootNamespace, branch, commitId, includeCommitIdMetadata);
            });

        // Look for AppVersionConfigAttribute in assembly attributes
        var configAttributeProvider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "SimpleBranchVersioning.AppVersionConfigAttribute",
                predicate: static (node, _) => node is CompilationUnitSyntax,
                transform: static (ctx, _) => GetConfigFromAttribute(ctx))
            .Collect()
            .Select((configs, _) => configs.IsDefaultOrEmpty ? null : configs[0]);

        // Detect if the project uses top-level statements
        var hasTopLevelStatementsProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is GlobalStatementSyntax,
                transform: static (_, _) => true)
            .Collect()
            .Select((results, _) => !results.IsDefaultOrEmpty);

        // Combine all the inputs
        var combined = buildPropertiesProvider
            .Combine(configAttributeProvider)
            .Combine(hasTopLevelStatementsProvider);

        // Register the source output
        context.RegisterSourceOutput(combined, static (ctx, input) =>
        {
            var ((buildProps, config), hasTopLevelStatements) = input;

            string branch = string.IsNullOrEmpty(buildProps.Branch) ? "unknown" : buildProps.Branch!;
            string commitId = string.IsNullOrEmpty(buildProps.CommitId) ? "0000000" : buildProps.CommitId!;

            // Calculate all version formats
            var versionInfo = VersionCalculator.Calculate(branch, commitId, buildProps.IncludeCommitIdMetadata);

            // Determine namespace:
            // 1. If config specifies namespace explicitly, use it (empty string = global namespace)
            // 2. If top-level statements detected and no config, use global namespace
            // 3. Otherwise use RootNamespace or fallback
            string? namespaceName;
            if (config?.Namespace != null)
            {
                namespaceName = config.Namespace.Length == 0 ? null : config.Namespace;
            }
            else if (hasTopLevelStatements)
            {
                namespaceName = null; // Global namespace for top-level statement apps
            }
            else
            {
                namespaceName = buildProps.RootNamespace ?? "SimpleBranchVersioning.Generated";
            }
            string className = config?.ClassName ?? "AppVersion";

            string source = GenerateSource(namespaceName, className, versionInfo, branch, commitId);
            ctx.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));

            // Generate assembly version attributes
            string assemblyAttributesSource = GenerateAssemblyAttributes(versionInfo);
            ctx.AddSource("AssemblyVersionInfo.g.cs", SourceText.From(assemblyAttributesSource, Encoding.UTF8));

            // Generate version file writer helper (always in fixed namespace for MSBuild to find)
            string writerSource = GenerateVersionFileWriter(versionInfo, branch, commitId);
            ctx.AddSource("VersionFileWriter.g.cs", SourceText.From(writerSource, Encoding.UTF8));
        });
    }

    private static AppVersionConfig? GetConfigFromAttribute(GeneratorAttributeSyntaxContext context)
    {
        var attribute = context.Attributes.FirstOrDefault();
        if (attribute is null)
        {
            return null;
        }

        string? namespaceName = null;
        string? className = null;

        foreach (var arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "Namespace":
                    namespaceName = arg.Value.Value as string;
                    break;
                case "ClassName":
                    className = arg.Value.Value as string;
                    break;
            }
        }

        return new AppVersionConfig(namespaceName, className);
    }

    private static string GenerateAssemblyAttributes(VersionInfo versionInfo)
    {
        return $"""
            // <auto-generated/>
            [assembly: global::System.Reflection.AssemblyVersion("{versionInfo.AssemblyVersion}")]
            [assembly: global::System.Reflection.AssemblyFileVersion("{versionInfo.FileVersion}")]
            [assembly: global::System.Reflection.AssemblyInformationalVersion("{versionInfo.InformationalVersion}")]
            """;
    }

    private static string GenerateVersionFileWriter(VersionInfo versionInfo, string branch, string commitId)
    {
        return $$"""
            // <auto-generated/>
            namespace SimpleBranchVersioning.Generated
            {
                [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
                internal static class VersionFileWriter
                {
                    public static void WriteJson(string path)
                    {
                        string json = "{\n" +
                            "  \"Version\": \"{{EscapeJson(versionInfo.Version)}}\",\n" +
                            "  \"Branch\": \"{{EscapeJson(branch)}}\",\n" +
                            "  \"CommitId\": \"{{EscapeJson(commitId)}}\",\n" +
                            "  \"PackageVersion\": \"{{EscapeJson(versionInfo.PackageVersion)}}\",\n" +
                            "  \"AssemblyVersion\": \"{{EscapeJson(versionInfo.AssemblyVersion)}}\",\n" +
                            "  \"FileVersion\": \"{{EscapeJson(versionInfo.FileVersion)}}\",\n" +
                            "  \"InformationalVersion\": \"{{EscapeJson(versionInfo.InformationalVersion)}}\"\n" +
                            "}";
                        global::System.IO.File.WriteAllText(path, json);
                    }
                }
            }
            """;
    }

    private static string EscapeJson(string value) =>
        value.Replace("\\", "\\\\").Replace("\"", "\\\"");

    private static string GenerateSource(string? namespaceName, string className, VersionInfo versionInfo, string branch, string commitId)
    {
        string classDefinition = $$"""
            /// <summary>
            /// Contains version information generated from git.
            /// </summary>
            public static class {{className}}
            {
                /// <summary>
                /// The display version string (backward compatible format).
                /// </summary>
                public const string Version = "{{versionInfo.Version}}";

                /// <summary>
                /// The git branch name.
                /// </summary>
                public const string Branch = "{{branch}}";

                /// <summary>
                /// The short git commit ID.
                /// </summary>
                public const string CommitId = "{{commitId}}";

                /// <summary>
                /// NuGet-compatible package version.
                /// </summary>
                public const string PackageVersion = "{{versionInfo.PackageVersion}}";

                /// <summary>
                /// Assembly version (X.Y.Z.0 format).
                /// </summary>
                public const string AssemblyVersion = "{{versionInfo.AssemblyVersion}}";

                /// <summary>
                /// File version (same as AssemblyVersion).
                /// </summary>
                public const string FileVersion = "{{versionInfo.FileVersion}}";

                /// <summary>
                /// Informational version with full metadata.
                /// </summary>
                public const string InformationalVersion = "{{versionInfo.InformationalVersion}}";
            }
            """;

        if (namespaceName == null)
        {
            return $"""
                // <auto-generated/>
                #nullable enable

                {classDefinition}
                """;
        }

        // Indent the class definition for namespace
        string indentedClass = string.Join(
            "\n",
            classDefinition.Split('\n')
                .Select(line => string.IsNullOrWhiteSpace(line) ? line.TrimEnd('\r') : "    " + line.TrimEnd('\r')));

        return $$"""
            // <auto-generated/>
            #nullable enable

            namespace {{namespaceName}}
            {
            {{indentedClass}}
            }
            """;
    }

#pragma warning disable RS1035 // File IO is intentional - we need to read git info
    private static (string? branch, string? commitId)? ParseGitInfo(string? headContent, string? gitDir)
    {
        if (string.IsNullOrEmpty(headContent) || string.IsNullOrEmpty(gitDir))
        {
            return null;
        }

        string? branch = null;
        string? commitId = null;

        // Parse HEAD - either "ref: refs/heads/branch-name" or a commit hash
        if (headContent!.StartsWith("ref: refs/heads/", StringComparison.Ordinal))
        {
            branch = headContent.Substring(16);

            // Read commit from ref file
            string refPath = Path.Combine(gitDir!, "refs", "heads", branch);
            if (File.Exists(refPath))
            {
                string commit = File.ReadAllText(refPath).Trim();
                if (commit.Length >= 7)
                {
                    commitId = commit.Substring(0, 7);
                }
            }
        }
        else if (headContent.Length >= 7 && Regex.IsMatch(headContent, "^[0-9a-f]+$", RegexOptions.None, TimeSpan.FromSeconds(1)))
        {
            // Detached HEAD - commit hash directly in HEAD
            branch = "detached";
            commitId = headContent.Substring(0, 7);
        }

        return (branch, commitId);
    }

    private static (string? branch, string? commitId) ReadGitInfo(string? projectDir)
    {
        if (string.IsNullOrEmpty(projectDir))
        {
            return (null, null);
        }

        // Find .git directory by walking up the directory tree
        var dir = new DirectoryInfo(projectDir);
        string? gitDir = null;

        while (dir != null)
        {
            string gitPath = Path.Combine(dir.FullName, ".git");
            if (Directory.Exists(gitPath))
            {
                gitDir = gitPath;
                break;
            }

            dir = dir.Parent;
        }

        if (gitDir == null)
        {
            return (null, null);
        }

        // Read HEAD file
        string headPath = Path.Combine(gitDir, "HEAD");
        if (!File.Exists(headPath))
        {
            return (null, null);
        }

        string headContent = File.ReadAllText(headPath).Trim();

        string? branch = null;
        string? commitId = null;

        // Parse HEAD - either "ref: refs/heads/branch-name" or a commit hash
        if (headContent.StartsWith("ref: refs/heads/", StringComparison.Ordinal))
        {
            branch = headContent.Substring(16);

            // Read commit from ref file
            string refPath = Path.Combine(gitDir, "refs", "heads", branch);
            if (File.Exists(refPath))
            {
                string commit = File.ReadAllText(refPath).Trim();
                if (commit.Length >= 7)
                {
                    commitId = commit.Substring(0, 7);
                }
            }
        }
        else if (headContent.Length >= 7 && Regex.IsMatch(headContent, "^[0-9a-f]+$", RegexOptions.None, TimeSpan.FromSeconds(1)))
        {
            // Detached HEAD - commit hash directly in HEAD
            branch = "detached";
            commitId = headContent.Substring(0, 7);
        }

        return (branch, commitId);
    }
#pragma warning restore RS1035

    private sealed record BuildProperties(string? RootNamespace, string? Branch, string? CommitId, bool IncludeCommitIdMetadata);
    private sealed record AppVersionConfig(string? Namespace, string? ClassName);
}
